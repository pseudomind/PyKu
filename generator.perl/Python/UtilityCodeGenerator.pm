package Python::Package;
use strict;

sub generate_utility_h_code {
	my ($self, $folder) = @_;
	
	my $filename = File::Spec->catfile($folder, "$self->{filename}Utils.h");
	open my $fh, ">$filename" or die "Unable to create file '$filename': $!";
	
	print $fh <<TOP;
/*
 * Automatically generated file
 */
 
TOP
	
	print $fh <<UTIL;
// comment this out to disallow debugging
#define DEBUGOK

#ifdef DEBUGOK
#define DEBUGME(LEVEL, PATTERN, ...) debug_me(LEVEL, __FILE__, __LINE__, PATTERN, ##__VA_ARGS__)
#else
#define DEBUGME(LEVEL, PATTERN, ...)
#endif

int debug_level = 0;

void debug_me(int level, const char* file, int line, const char* pattern, ...);

char** PyList2CharArray(PyObject* arg, int* count);
PyObject* CharArray2PyList(char** var, int count);
void PyString2Char(PyObject* arg, void* var, int num_chars, int size);
PyObject* Char2PyString(const void* var, int num_chars, int size);
UTIL
	
	close $fh;
}

sub generate_utility_cpp_code {
	my ($self, $folder) = @_;
	
	my $filename = File::Spec->catfile($folder, "$self->{filename}Utils.cpp");
	open my $fh, ">$filename" or die "Unable to create file '$filename': $!";
	
	print $fh <<UTIL;
/*
 * Automatically generated file
 */
 
#include "$self->{filename}Utils.h"

void debug_me(int level, const char* file, int line, const char* pattern, ...) {
	if (! (debug_level & level))
		return;
	
	va_list args;
	va_start(args, pattern);
	printf(pattern, &args);
	va_end(args);
	
	printf("\t...generated by %s line %d\\n", file, line);
}

char** PyList2CharArray(PyObject* arg, int* count) {
	char** ret;
	int i;
	
	*count = PyList_Size(arg);
	ret = (char**)malloc(*count);
	//will need to free this memory - but when?
	
	for (i = 0; i < *count; i++) {
		PyObject * pystring = 0;
		pystring = PyList_GetItem(arg, i);
		ret[i] = PyString_AsString(pystring);
	}
	
	return ret;
}

PyObject* CharArray2PyList(char** var, int count) {
	PyObject* list = PyList_New(0);
	int i;
	
	for (i = 0; i < count; i++) {
		PyList_Append(list, PyString_FromString(var[i]));
	}
	
	return list;
}

void PyString2Char(PyObject* arg, void* var, int num_chars, int size) {
	size_t length;
	char* pystring_contents;
	Py_ssize_t pystring_length;
	
	PyString_AsStringAndSize(arg, &pystring_contents, &pystring_length);
	length = num_chars * size;
	if (pystring_length < (int)length) {
		length = pystring_length;
	}
	
	memcpy(var, (void*)pystring_contents, pystring_length);
}

PyObject* Char2PyString(const void* var, int num_chars, int size) {
	PyObject* ret;
	Py_ssize_t pystring_length;
	
	pystring_length = num_chars * size;
	ret = PyString_FromStringAndSize((char*)var, (int)pystring_length);
	
	return ret;
}

UTIL
	
	close $fh;
}

1;
