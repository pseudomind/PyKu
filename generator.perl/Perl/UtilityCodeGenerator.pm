package Perl::Module;
use strict;

sub generate_utility_h_code {
	my ($self, $folder) = @_;
	
	my $filename = File::Spec->catfile($folder, "$self->{filename}.h");
	open my $fh, ">$filename" or die "Unable to create file '$filename': $!";
	
	print $fh <<TOP;
/*
 * Automatically generated file
 */
 
TOP
	
	if ($self->has('include')) {
		for my $file ($self->include->files) {
			print $fh "#include <", $file->name, ">\n";
		}
		print $fh "\n";
	}
	
	if ($self->{includes}) {
		for my $file (@{ $self->{includes} }) {
			print $fh "#include <$file>\n";
		}
		print $fh "\n";
	}
	
	if (my @qualified = $self->types->qualified_types) {
		print $fh "// xsubpp will mangle qualified types in INPUT, so we provide a workaround\n";
		for my $qname (@qualified) {
			(my $name = $qname)=~s/:/_/g;
			print $fh "typedef $qname $name;\n";
		}
		print $fh "\n";
	}
	
	print $fh <<UTIL;
// comment this out to disallow debugging
#define DEBUGOK

#ifdef DEBUGOK
#define DEBUGME(LEVEL, PATTERN, ...) debug_me(LEVEL, __FILE__, __LINE__, PATTERN, ##__VA_ARGS__)
#else
#define DEBUGME(LEVEL, PATTERN, ...)
#endif

#ifdef DEBUGOK
#define DUMPME(LEVEL, ARG) dump_me(LEVEL, __FILE__, __LINE__, ARG)
#else
#define DUMPME(LEVEL, ARG)
#endif

int debug_level = 0;

void set_up_debug_sv();
void debug_me(int level, const char* file, int line, const char* pattern, ...);
void dump_me(int level, const char* file, int line, SV* arg);

struct object_link_data {
	void* cpp_object;
	SV*   perl_object;
	bool  can_delete_cpp_object;
	const char* perl_class_name;
};

SV* create_perl_object(void* cpp_obj_address, const char* perl_class_name, bool must_not_delete = false);
object_link_data* get_link_data(SV* perl_obj);
void unlink_perl_object(SV* perl_obj);
void must_not_delete_cpp_object(SV* perl_obj, bool must_not_delete);
void* get_cpp_object(SV* perl_obj);
bool can_delete_cpp_object(SV* perl_obj);

void dualize(SV* arg, const char* string);

UTIL
	
	close $fh;
}

sub generate_utility_cpp_code {
	my ($self, $folder) = @_;
	
	my $filename = File::Spec->catfile($folder, "$self->{filename}.cpp");
	open my $fh, ">$filename" or die "Unable to create file '$filename': $!";
	
	print $fh <<UTIL;
/*
 * Automatically generated file
 */
 
#include "$self->{filename}.h"
 	
void set_up_debug_sv(const char* name) {
	SV* tie_obj;
	HV* tie_obj_stash;
	
	// create an sv and make it a reference to another (new and empty) sv
	tie_obj = newSV(0);
	newSVrv(tie_obj, NULL);
		
	// bless the reference into the name'd class
	tie_obj_stash = gv_stashpv(name, TRUE);
	sv_bless(tie_obj, tie_obj_stash);
		
	// tie the blessed object to the name'd scalar
	sv_magic(get_sv(name, 1), tie_obj, PERL_MAGIC_tiedscalar, NULL, 0);
}

void debug_me(int level, const char* file, int line, const char* pattern, ...) {
	if (! (debug_level & level))
		return;
	
	va_list args;
	va_start(args, pattern);
	vwarn(pattern, &args);
	va_end(args);
	
	warn("\\t...generated by %s line %d\\n", file, line);
}

void dump_me(int level, const char* file, int line, SV* arg) {
	if (! (debug_level & level))
		return;
		
	sv_dump(arg);
	warn("...at %s line %d\\n", file, line);
}

SV* create_perl_object(void* cpp_obj, const char* perl_class_name, bool must_not_delete) {
	HV* underlying_hash;
	SV* perl_obj;
	HV* perl_obj_stash;
	object_link_data* link = new object_link_data;
	
	if (cpp_obj == NULL)
		return &PL_sv_undef;
		
	// create the underlying hash and make a ref to it
	underlying_hash = newHV();
	perl_obj = newRV_noinc((SV*)underlying_hash);
	//sv_2mortal(perl_obj);
	
	// get the stash and bless the ref (to the underlying hash) into it
	perl_obj_stash = gv_stashpv(perl_class_name, TRUE);
	sv_bless(perl_obj, perl_obj_stash);
	
	// fill in the data fields
	link->cpp_object = cpp_obj;
	link->perl_object = (SV*)underlying_hash;
	link->can_delete_cpp_object = must_not_delete ? false : true;
	link->perl_class_name = perl_class_name;
	
	// link the data via '~' magic
	// (we link to the underlying hash and not to the reference itself)
	sv_magic((SV*)underlying_hash, NULL, PERL_MAGIC_ext, (const char*)link, 0);	// cheat by storing data instead of a string
	
	// check this object
	DUMPME(1,perl_obj);
	
	return perl_obj;
}

object_link_data* get_link_data(SV* perl_obj) {
	SV* underlying_hash;
	MAGIC* mg;

	// get the underlying hash that the perl_obj is a reference to
	// (we can leave it an SV* because we're just using it to find magic)
	underlying_hash = SvRV(perl_obj);
	
	// get the data linked to the underlying hash
	mg = mg_find(underlying_hash, PERL_MAGIC_ext);
	if (mg == NULL)
		return NULL;
	
	// check this object
	DUMPME(1,perl_obj);
	
	return (object_link_data*)mg->mg_ptr;
}

void unlink_perl_object(SV* perl_obj) {
	SV* underlying_hash;
	object_link_data* link;
	
	// get the object linked to the perl_obj
	link = get_link_data(perl_obj);
	
	if (link == NULL)
		return;
	
	// remove the magical link
	underlying_hash = SvRV(perl_obj);
	sv_unmagic((SV*)underlying_hash, PERL_MAGIC_ext);
	
	// this is only ever called from DESTROY, which means
	// refcount should already be 0
	//SvREFCNT_dec(link->perl_object);	// decrement reference count
	link->perl_object = NULL;
	
	if (link->perl_object == NULL && link->cpp_object == NULL)
		delete link;
}

void must_not_delete_cpp_object(SV* perl_obj, bool must_not_delete) {
	object_link_data* link;
	
	// get the object linked to the perl_obj
	link = get_link_data(perl_obj);
	
	if (link == NULL)
		return;
	
	// update the value
	link->can_delete_cpp_object = must_not_delete ? false : true;
}

void* get_cpp_object(SV* perl_obj) {
	object_link_data* link;
	
	// get the object linked to the perl_obj
	link = get_link_data(perl_obj);
	
	if (link == NULL)
		return NULL;
	
	return link->cpp_object;
}

bool can_delete_cpp_object(SV* perl_obj) {
	object_link_data* link;
	
	// get the object linked to the perl_obj
	link = get_link_data(perl_obj);
	
	if (link == NULL)
		return false;
	
	return link->can_delete_cpp_object;
}

void dualize(SV* arg, const char* string) {
	svtype sv_type;
	
	sv_type = SvTYPE(arg);
	switch(sv_type) {
		case SVt_IV:
			SvUPGRADE(arg, SVt_PVIV);
			sv_setpv(arg, string);
			SvIOK_on(arg);
			break;
		
		case SVt_NV:
			SvUPGRADE(arg, SVt_PVNV);
			sv_setpv(arg, string);
			SvNOK_on(arg);
			break;
		
		// how do we do this for blessed refs?
		// this doesn't work
		case SVt_PVMG:
			sv_setpv(arg, string);
			break;
		
		default:
			DEBUGME(2, "Got svtype of %d", sv_type);
	}
}

UTIL
	
	close $fh;
}

1;
